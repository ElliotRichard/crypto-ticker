{"ast":null,"code":"import { of, forkJoin } from 'rxjs';\nimport { tap, mergeMap, map, delay, repeat, repeatWhen } from 'rxjs/operators';\nimport { CoinFactory } from '../classes/Coins';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nlet cryptoCoins = ['BTCUSDT', 'ETHUSDT', 'SHIBUSDT', 'BUSDUSDT', 'DOGEUSDT'];\nlet service = 'https://api2.binance.com/api/v3';\nexport var sortOption = /*#__PURE__*/(() => {\n  (function (sortOption) {\n    sortOption[sortOption[\"price\"] = 0] = \"price\";\n    sortOption[sortOption[\"name\"] = 1] = \"name\";\n  })(sortOption || (sortOption = {}));\n\n  return sortOption;\n})();\nexport let CryptoService = /*#__PURE__*/(() => {\n  class CryptoService {\n    constructor(http) {\n      this.http = http;\n      this.sortBy = sortOption.name;\n    }\n    /**\r\n     * Returns a copy of stocks so that they are not directly modified.\r\n     * @returns A copy of stocks\r\n     */\n\n\n    get() {\n      return cryptoCoins.slice();\n    }\n    /**\r\n     * Adds a crypto coin to the list to be watched.\r\n     * @param crypto The coin to add\r\n     * @returns the updated lists of coins\r\n     */\n\n\n    add(crypto) {\n      cryptoCoins.push(crypto);\n      return this.get();\n    }\n    /**\r\n     * Removes a coin from the list being watched.\r\n     * @param crypto the coin being removed\r\n     * @returns the updated list of coins\r\n     */\n\n\n    remove(crypto) {\n      cryptoCoins.splice(cryptoCoins.indexOf(crypto), 1);\n      return this.get();\n    }\n    /**\r\n     * Repeatedly requests the current price of the coins from the free Binance API.\r\n     * @param symbols coins being requested\r\n     * @returns the data as an observable\r\n     */\n\n\n    load() {\n      let repeatStatus = undefined;\n      return of(cryptoCoins).pipe(repeatWhen(_ => _.pipe(delay(2000), repeat(repeatStatus))), mergeMap(symbols => {\n        const requestArrays = symbols.map(symbol => {\n          return this.http.get(service + '/ticker/24hr?symbol=' + symbol, {\n            observe: 'response'\n          }).pipe(tap(response => {\n            // 429 means the rate limit is reached\n            if (response.status === 429) {\n              repeatStatus = 0;\n            }\n          }), map(response => {\n            return CoinFactory.makeCoinFromResponse(response.body);\n          }));\n        });\n        return forkJoin(requestArrays);\n      }), map(coins => {\n        return this._sort(coins);\n      }));\n    }\n\n    setSort(option) {\n      this.sortBy = option;\n    }\n\n    getSort() {\n      return this.sortBy;\n    }\n\n    _sort(coins) {\n      switch (this.sortBy) {\n        case sortOption.name:\n          coins.sort((a, b) => a.name.localeCompare(b.name));\n          break;\n\n        case sortOption.price:\n          coins.sort((a, b) => b.price - a.price);\n          break;\n      }\n\n      return coins;\n    }\n\n  }\n\n  CryptoService.ɵfac = function CryptoService_Factory(t) {\n    return new (t || CryptoService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  CryptoService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CryptoService,\n    factory: CryptoService.ɵfac,\n    providedIn: 'root'\n  });\n  return CryptoService;\n})();","map":null,"metadata":{},"sourceType":"module"}